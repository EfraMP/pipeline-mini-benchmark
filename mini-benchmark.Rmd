---
title: "Mini-benchmark"
author: "Alejandro Efraín Marín Peralta"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
  pdf_document:
    toc: true
    toc_depth: '3'
---


```{r libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(arrow)
library(readr)
library(magrittr)
library(eulerr)
#library(mlr3measures)
#library(units)
library(lubridate)
library(UpSetR)
```


```{r data_load}
setwd("~/Documents/EMBL_UniHD/pipeline_res")

msconvert_diannv1.9.2 <- open_dataset("./sc_minibm_good_fasta/msconvert_diannv1.9.2/report.parquet",
                                      format = "parquet")


thermoraw_diannv1.9.2 <- open_dataset("./sc_minibm_good_fasta/thermoraw_diannv1.9.2/report.parquet", format = "parquet")


msconvert_diannv2.0 <- open_dataset("./sc_minibm_good_fasta/msconvert_diannv2.0/report.parquet",
                                    format = "parquet")

thermoraw_diannv2.0 <- open_dataset("./sc_minibm_good_fasta/thermoraw_diannv2.0/report.parquet",
                                    format = "parquet")

msconvert_diannv2.0.1 <- open_dataset("./sc_minibm_good_fasta/msconvert_diannv2.0.1/report.parquet",
                                    format = "parquet")

thermoraw_diannv2.0.1 <- open_dataset("./sc_minibm_good_fasta/thermoraw_diannv2.0.1/report.parquet",
                                    format = "parquet")

msconvert_diannv2.0.2 <- open_dataset("./sc_minibm_good_fasta/msconvert_diannv2.0.2/report.parquet",
                                    format = "parquet")

thermoraw_diannv2.0.2 <- open_dataset("./sc_minibm_good_fasta/thermoraw_diannv2.0.2/report.parquet",
                                    format = "parquet")

diannv2.1.0 <- open_dataset("./sc_minibm_good_fasta/diannv2.1.0/report.parquet",
                                    format = "parquet")

parquets <- c(
  "msconvert_diannv1.9.2",
  "thermoraw_diannv1.9.2",
  "msconvert_diannv2.0",
  "thermoraw_diannv2.0",
  "msconvert_diannv2.0.1",
  "thermoraw_diannv2.0.1",
  "msconvert_diannv2.0.2",
  "thermoraw_diannv2.0.2",
  "diannv2.1.0"
  )

## TSVs and parquets
all_runs <- c(
  # "msconvert_diannv1.9.2",
  # "thermoraw_diannv1.9.2",
  parquets
)

```


```{r functions}
# Auxiliary functions

## Get protein groups from parquet DIA-NN output
pg <- function(x) {
  x %>% 
    collect() %>% 
    pull(Protein.Group) %>% 
    unique()
}


## Get proteins from parquet DIA-NN output
proteins <- function(x) {
  x %>% 
    collect() %>% 
    pull(Protein.Ids) %>% 
    unique()
}

## Get peptides from parquet DIA-NN output
peptides <- function(x) {
  x %>% 
    collect() %>% 
    pull(Stripped.Sequence) %>% 
    unique()
}


### Function to convert units to MB
get_MB <- function(x) {
  ## Trim whitespace
  x %<>% as.character() %>% 
    trimws()
  
  ## Gets numeric value
  val <- str_extract(x, "[0-9]+(\\.[0-9]+)?") %>% 
    as.numeric()
  
  ## Gets unit
  unit <- str_extract(x, "[A-Za-z]+") %>% 
    toupper()
  
  ## Gets MB
  value_mb = case_when(
    unit == "KB" ~ val / 1024,
    unit == "MB" ~ val,
    unit == "GB" ~ val * 1024,
    TRUE ~ NA_real_
  )
  
  ## Return megabytes
  return(value_mb)
}


## Function to get time information into seconds
get_seconds <- function(x) {
  x %<>% as.character()
  
  ## Gets time with regex
  h <- x %>% 
    str_extract(., "\\d+(?=h)") %>% 
    as.numeric()
  m <- x %>% 
    str_extract(., "\\d+(?=m)") %>% 
    as.numeric()
  ## Regex to allow decimal seconds
  s <- x %>% 
    str_extract(., "\\d+(?:\\.\\d+)?(?=s)") %>% 
    as.numeric()
  
  # Replace NAa with 0
  h[is.na(h)] <- 0
  m[is.na(m)] <- 0
  s[is.na(s)] <- 0
  
  ## Return seconds
  return(h * 3600 + m * 60 + s)
}


## Function to add raw conversion tool and DIA-NN version into new columns of the traces
## The input is the specif name of the trace
add_meta <- function(x) {
  s <- 0
  
}



## Flat violin function
geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",
                             position = "dodge", trim = TRUE, scale = "area",
                             show.legend = NA, inherit.aes = TRUE, ...) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomFlatViolin,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      trim = trim,
      scale = scale,
      ...
    )
  )
}

#' @rdname ggplot2-ggproto
#' @format NULL
#' @usage NULL
#' @export
GeomFlatViolin <-
  ggproto("GeomFlatViolin", Geom,
          setup_data = function(data, params) {
            data$width <- data$width %||%
              params$width %||% (resolution(data$x, FALSE) * 0.9)
            
            # ymin, ymax, xmin, and xmax define the bounding rectangle for each group
            data %>%
              group_by(group) %>%
              mutate(ymin = min(y),
                     ymax = max(y),
                     xmin = x,
                     xmax = x + width / 2)
            
          },
          
          draw_group = function(data, panel_scales, coord) {
            # Find the points for the line to go all the way around
            data <- transform(data, xminv = x,
                              xmaxv = x + violinwidth * (xmax - x))
            
            # Make sure it's sorted properly to draw the outline
            newdata <- rbind(plyr::arrange(transform(data, x = xminv), y),
                             plyr::arrange(transform(data, x = xmaxv), -y))
            
            # Close the polygon: set first and last point the same
            # Needed for coord_polar and such
            newdata <- rbind(newdata, newdata[1,])
            
            ggplot2:::ggname("geom_flat_violin", GeomPolygon$draw_panel(newdata, panel_scales, coord))
          },
          
          draw_key = draw_key_polygon,
          
          default_aes = aes(weight = 1, colour = "grey20", fill = "white", linewidth = 0.5,
                            alpha = NA, linetype = "solid"),
          
          required_aes = c("x", "y")
  )




```



## Unique Protein Groups

```{r pg}
pg_msconvert_diannv1.9.2 <- msconvert_diannv1.9.2$Protein.Group %>% unique()
pg_thermoraw_diannv1.9.2 <- thermoraw_diannv1.9.2$Protein.Group %>% unique()


for (i in parquets) {
  obj <- get(i)
  assign(paste0("pg_", i), pg(obj))
}

```



## Unique Proteins

```{r uniq_prots}
## TSV files
prots_msconvert_diannv1.9.2 <- msconvert_diannv1.9.2$Protein.Ids %>% unique() 
prots_thermoraw_diannv1.9.2 <- thermoraw_diannv1.9.2$Protein.Ids %>% unique()

## Parquet files
for (i in parquets) {
  obj <- get(i)
  assign(paste0("prots_", i), proteins(obj))
}

```


## Unique Peptides


```{r uniq_pepts}
## TSV files
pepts_msconvert_diannv1.9.2 <- msconvert_diannv1.9.2$Stripped.Sequence %>% unique()
pepts_thermoraw_diannv1.9.2 <- thermoraw_diannv1.9.2$Stripped.Sequence %>% unique()

## Parquet files
for (i in parquets) {
  obj <- get(i)
  assign(paste0("pepts_", i), peptides(obj))
}
```



## Traces


```{r traces}
## Get all Nextflow run traces
for (i in all_runs) {
  obj <- i %>%
    paste0("./sc_minibm_good_fasta/", ., "/trace.tsv") %>%
    read.csv(sep = "\t") %T>% 
    ## Tee pipe to make the pipe function
    { assign(paste0("trace_", i), ., envir = .GlobalEnv) }
}

## Format traces for analysis
for (i in all_runs) {
  ## Manages the name of the object
  name <- paste0("trace_", i)
  obj <- get(name)
  
  ## Convert time metrics to seconds
  obj %<>% mutate(duration_seconds = get_seconds(obj$duration))
  obj %<>% mutate(realtime_seconds = get_seconds(obj$realtime))
  
  ## Convert memory metrics to MB
  obj %<>% mutate(peak_rss_MB = get_MB(obj$peak_rss))
  obj %<>% mutate(peak_vmem_MB = get_MB(obj$peak_vmem))
  obj %<>% mutate(rchar_MB = get_MB(obj$rchar))
  obj %<>% mutate(wchar_MB = get_MB(obj$wchar))
  
  ## Get CPU percentage 
  obj %<>% mutate(cpu_percentage = obj %>% 
                    pluck("X.cpu") %>% 
                    str_remove("%") %>% 
                    as.numeric()
  )
  
  ## 
  assign(name, obj)
}
```


## Shared bio elements

```{r shared_pgs}
## Gets all protein groups
pg_list <- ls(pattern = "^pg_", envir = .GlobalEnv) %>% 
  mget(., envir = .GlobalEnv, ifnotfound = list(NULL))
pg_list %<>% Filter(Negate(is.null), .)

## Upset plot
pg_list %>% fromList() %>% 
  upset()
```


```{r shared_proteins}
prots_list <- ls(pattern = "^prots_", envir = .GlobalEnv) %>%
  mget(., envir = .GlobalEnv, ifnotfound = list(NULL))
prots_list %<>% Filter(Negate(is.null), .)

## Upset plot
prots_list %>% fromList() %>% 
  upset()
```

```{r shared_peptides}
pepts_list <- ls(pattern = "^pepts_", envir = .GlobalEnv) %>% 
  mget(., envir = .GlobalEnv, ifnotfound = list(NULL))
pepts_list %<>% Filter(Negate(is.null), .)

## Upset plot
pepts_list %>% fromList() %>% 
  upset()
```






## Computational metrics


```{r all_traces}
## Get all data frame into the same object
trace_list <- ls(pattern = "^trace_.*_diannv[0-9]+(\\.[0-9]+)+$") %>% 
  mget(., envir = .GlobalEnv, ifnotfound = list(NULL))

## Add mzML conversion tool and DIA-NN version to list
# imap() supplies the value (x) and key (y) automatically to the anonymous function
trace_list %<>%  imap(function(x, y) { 
  tool <- sub("^trace_([^_]+)_.*", "\\1", y)
  diann_version <- sub("^trace_[^_]+_(diannv.+)$", "\\1", y)
  
  x %>% mutate(tool = tool,
               diann_version = diann_version)
})


## Add meta data to diann2.1

trace_diannv2.1.0$tool <- "diannv2.1.0"
trace_diannv2.1.0$diann_version <- "diannv2.1.0"


## Merge all
combined_trace <- bind_rows(trace_list)

##combined_trace %<>% bind_rows(trace_diannv2.1.0)

## Get summary stats
summary_stats <- combined_trace %>%
  group_by(tool, diann_version) %>%
  summarise(
    median_runtime = median(duration_seconds, na.rm = TRUE),
    mean_runtime   = mean(duration_seconds, na.rm = TRUE),
    median_peak_rss = median(peak_rss_MB, na.rm = TRUE),
    mean_cpu       = mean(cpu_percentage, na.rm = TRUE)
  )


## Plot
ggplot() +
  geom_boxplot(data = combined_trace, 
               aes(x = tool, y = duration_seconds/60, fill = diann_version)) +
  geom_jitter(data = trace_diannv2.1.0, 
              aes(x = tool, y = duration_seconds/60, color = diann_version),
              width = 0.2) +
  labs(title = "Runtime Comparison", x = "Tool", y = "Runtime (min)") +
  theme_minimal()

```



## mzML conversion

```{r mzml}
## Get just mzML conversion metrics
mzml_metrics <- combined_trace %>%
  filter(str_detect(name, "raw_to_mzml"))

## Real runtime
ggplot(mzml_metrics, aes(x = tool, y = realtime_seconds/60, fill = tool)) +
  ylim(c(0, max(mzml_metrics$realtime_seconds/60))) +
  geom_flat_violin(alpha = 0.7, position = position_nudge(x = .2, y = 0)) +
  geom_jitter(alpha = 0.7, width = 0.15) +
  geom_boxplot(alpha = 0.7, width = .25,  outlier.shape = NA) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(title = "Runtime Comparison", x = "Tool", y = "Runtime (min)")

## Peak of real memory
ggplot(mzml_metrics, aes(x = tool, y = peak_rss_MB, fill = tool)) +
  ylim(c(0, max(mzml_metrics$peak_rss_MB))) +
  geom_jitter(alpha = 0.7, width = 0.13) +
  geom_boxplot(alpha = 0.7, width = .25,  outlier.shape = NA) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(title = "Peak of real memory", x = "Tool", y = "Memory (MB)")

## Peak of virtual memory
ggplot(mzml_metrics, aes(x = tool, y = peak_vmem_MB, fill = tool)) +
  ylim(c(0, max(mzml_metrics$peak_vmem_MB))) +
  geom_jitter(alpha = 0.7, width = 0.13) +
  geom_boxplot(alpha = 0.7, width = .25,  outlier.shape = NA) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(title = "Peak of virtual memory", x = "Tool", y = "Memory (MB)")

## Read bytes
ggplot(mzml_metrics, aes(x = tool, y = rchar_MB, fill = tool)) +
  ylim(c(0, max(mzml_metrics$rchar_MB))) +
  geom_jitter(alpha = 0.7, width = 0.13) +
  geom_boxplot(alpha = 0.7, width = .25,  outlier.shape = NA) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(title = "Information read", x = "Tool", y = "Memory (MB)")

## Written bytes
ggplot(mzml_metrics, aes(x = tool, y = wchar_MB, fill = tool)) +
  ylim(c(0, max(mzml_metrics$wchar_MB))) +
  geom_jitter(alpha = 0.7, width = 0.13) +
  geom_boxplot(alpha = 0.7, width = .25,  outlier.shape = NA) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(title = "Information written", x = "Tool", y = "Memory (MB)")


## Percentage CPU
ggplot(mzml_metrics, aes(x = tool, y = cpu_percentage, fill = tool)) +
  ylim(c(0, max(mzml_metrics$cpu_percentage))) +
  geom_jitter(alpha = 0.7, width = 0.13) +
  geom_boxplot(alpha = 0.7, width = .25,  outlier.shape = NA) +
  theme_minimal() +
  theme(legend.position = "none") +
  labs(title = "Percentage of CPU used", x = "Tool", "% CPU")


```





## Quantification


```{r helper_matrix}
## Function to iterate across all results and get DIA-NN matrices into a list
get_matrix <- function(prefix) {
  
  matrix_list <- list()
  for (i in all_runs) {
    obj <- i %>%
      paste0("./sc_minibm_good_fasta/", ., "/report.", prefix, "_matrix.tsv") %>%
      read.csv(sep = "\t") %T>% 
      {
        ## Anonymous function to fix column name from Nextflow run
        ## tee pipe was needed
        colnames(.) <- sub(".*?([0-9]+_.*)", "\\1", colnames(.))
        .
      }
    matrix_list[[paste0(prefix, "_", i)]] <- obj
  }
  return(matrix_list)
}
```


### Protein groups

```{r}
pg_matrices <- get_matrix("pg")




```


### Gene groups

```{r}
gg_matrices <- get_matrix("gg")
```


### Unique genes

```{r}
unique_genes <- get_matrix("unique_genes")
```


### Precursors


```{r}
pr_matrices <- get_matrix("pr")
```





